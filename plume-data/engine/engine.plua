--[[This file is part of Plume

PlumeðŸª¶ is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

PlumeðŸª¶ is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with PlumeðŸª¶.
If not, see <https://www.gnu.org/licenses/>.
]]

-- Writed in my custom dirty preprocessor langage

return function (plume)
    function plume.run(runtime)
        local empty = plume.obj.empty
        local function _type(x)
            local t = type(x)
            if t=="table" then
                if t==empty then
                    return "empty"
                else
                    return t[1]
                end
            else
                return t
            end
        end

        --=====================--
        -- Instruction format --
        --=====================--
        local bit = require("bit")
        local OP_BITS   = 7
        local ARG1_BITS = 5
        local ARG2_BITS = 20
        local ARG1_SHIFT = ARG2_BITS
        local OP_SHIFT   = ARG1_BITS + ARG2_BITS
        local MASK_OP   = bit.lshift(1, OP_BITS) - 1
        local MASK_ARG1 = bit.lshift(1, ARG1_BITS) - 1
        local MASK_ARG2 = bit.lshift(1, ARG2_BITS) - 1

        --================--
        -- Initalization --
        --===============--
        require("table.new")

        local bytecode    = runtime.bytecode
        local constants   = runtime.constants
        local filesMemory = runtime.filesMemory

        local ip      = 0 -- instruction pointer
        local tic     = 0 -- total instruction count

        local ms   = table.new(2^14, 0) -- main stack
        local msf  = table.new(2^8, 0)  -- main stack frames (accumulators)
        local msp  = 0                  -- pointers
        local msfp = 0

        local vs   = table.new(2^10, 0)  -- variables stack
        local vsf  = table.new(2^8, 0)   -- variables stack frames (lexical scope)
        local vsp  = 0                   -- pointers
        local vsfp = 0

        local calls   = table.new(2^8, 0)  -- return from functions
        local cp      = 0 -- call pointer
        local memory  = table.new(2^8, 0)  -- return from files
                                           -- (not offsets, handled by functions,
                                           -- but static memory pointer)
        local mp      = 0 -- file memory pointer
        
        local jump    = 0 -- easier debuging than setting ip
        local instr, op, arg1, arg2 = 0, 0, 0, 0

        -- utils
        local limit = 0
        local macro, x, y 

        --debug
        local hook = plume.hook

        -----------
        -- ERROR -- 
        -----------
        @define _ERROR msg
            return false, $msg, ip
        @end

        ----------------
        -- LOOP ENTRY -- 
        ----------------
        @define _START
            if hook then
                if ip>0 then
                    hook(
                        tic, ip, jump,
                        instr, op, arg1, arg2,
                        ms, msp, msf, msfp,
                        vs, vsp, vsf, vsfp,
                        calls, cp,
                        memory, mp
                    )
                end
            end

            if jump>0 then
                ip = jump
                jump = 0-- 0 instead of nil to preserve type
            else
                ip = ip+1
            end
            tic = tic+1
        @end

        @define _DECODING
            instr = bytecode[ip]
            op    = bit.band(bit.rshift(instr, OP_SHIFT), MASK_OP)
            arg1  = bit.band(bit.rshift(instr, ARG1_SHIFT), MASK_ARG1)
            arg2  = bit.band(instr, MASK_ARG2)
        @end

        --=============--
        -- All OpCodes --
        --=============--

        ------------------
        -- LOAD / STORE --
        ------------------
        -- Constants
        @define LOAD_CONSTANT arg1 arg2
            --- Stack 1 from constant
            --- arg1: -
            --- arg2: constant offset
            msp = msp+1
            ms[msp] = constants[$arg2]
        @end

        @define LOAD_EMPTY arg1 arg2
            --- Stack 1 constant nil
            --- arg1: -
            --- arg2: -
            msp = msp+1
            ms[msp] = plume.obj.empty
        @end

        
        -- Variables
        @define LOAD_LOCAL arg1 arg2
            --- Stack 1 from vs.
            --- Final offset: current frame + vs offset
            --- arg1: -
            --- arg2: vs offset
            msp = msp+1
            ms[msp] = vs[vsf[vsfp] + $arg2-1]
        @end

        @define LOAD_LEXICAL arg1 arg2
            --- Stack 1 from vs.
            --- Final offset: the nth last frame + vs offset
            --- arg1: frame offset
            --- arg2: vs offset
            msp = msp+1
            ms[msp] = vs[vsf[vsfp-arg1]+$arg2-1]
        @end

        @define LOAD_STATIC arg1 arg2
            --- Stack 1 from static memory
            --- memory[mp] is a pointer to the current
            --- file intern memory
            --- arg1: -
            --- arg2: vs offset
            msp = msp+1
            ms[msp] = filesMemory[memory[mp]][$arg2]
        @end

        @define STORE_LOCAL arg1 arg2
            --- Unstack 1 to vs
            --- Final offset: current frame + frame offset
            --- arg1: -
            --- arg2: frame offset
            vs[vsf[vsfp] + $arg2-1] = ms[msp]
            msp = msp-1
        @end

        @define STORE_LEXICAL arg1 arg2
            --- Unstack 1 to vs
            --- Offset: the anth last frame + frame offset
            --- arg1: frame offset
            --- arg2: frame offset
            vs[vsf[vsfp-$arg1]+$arg2-1] = ms[msp]
            msp = msp-1
        @end

        @define STORE_STATIC arg1 arg2
            --- Unstack 1 static memory
            --- memory[mp] is a pointer to the current
            --- file intern memory
            --- arg1: -
            --- arg2: frame offset
            filesMemory[memory[mp]][$arg2] = ms[msp]
            msp = msp-1
        @end

        ----------
        -- Call --
        ----------
        @define _UNSTACK_POS
            x = msp-msf[msfp] --argcount
            if x ~= macro[3] then
                @_ERROR{{"Wrong number of positionnal arguments for macro '" .. macro[5] .. "', " ..   x .. " instead of " .. macro[3]}}
            end

            for i=1, x do
                vs[vsf[vsfp]+i-1] = ms[msp+i-x]
            end

            msp = msf[msfp]
        @end

        @define _UNSTACK_NAMED
            for k, v in pairs(ms[msf[msfp]]) do
                local i = macro[4][k]
                if not i then
                    @_ERROR{{"Unknow named parameter '" .. k .."' for macro '" .. macro[5] .."'."}}
                end
                vs[vsf[vsfp]+i-1] = v
            end    
            msp = msp-1
        @end

        @define ACC_CALL arg1 arg2
            --- Unstack 1 (the macro)
            --- Unstack until frame begin + 1 (all positionals arguments)
            --- Unstack 1 (table of named arguments)
            --- Create a new scope
            --- Stack all arguments to varstack
            --- Set jump to macro offset
            --- Stack current ip to calls
            --- arg1: -
            --- arg2: -
            macro = ms[msp]
            msp = msp - 1

            if _type(macro) == "macro" then
                @ENTER_SCOPE 0 macro[3]+#macro[4]

                @_UNSTACK_POS
                @_UNSTACK_NAMED

                jump = macro[2]

                cp = cp + 1
                calls[cp] = ip+1
            else
                @_ERROR {{"Try to call a '" .. _type(macro) .. "' value"}}
            end

            @_END_ACC
        @end
        
        @define RETURN arg1 arg2
            --- Unstack 1 from calls
            --- Set jump to it
            --- Leave scope
            --- arg1: -
            --- arg2: -
            jump = calls[cp]
            cp = cp - 1
            @LEAVE_SCOPE 0 0
        @end

        ---------
        -- ACC --
        ---------
        @define BEGIN_ACC arg1 arg2
            --- Stack 1 to main stack frame, the current msp
            --- arg1: -
            --- arg2: -
            msfp = msfp + 1
            msf[msfp] = msp+1
        @end

        @define _END_ACC arg1 arg2
            msfp = msfp-1
        @end

        @define ACC_TEXT arg1 arg2
            --- Unstack all until main stack frame begin
            --- Concat and main stack the result
            --- Unstack main stack frame
            --- arg1: -
            --- arg2: -
            limit = msf[msfp]
            if msp-limit>=1 then
                ms[limit] = table.concat(ms, "", limit, msp)
            else
                ms[limit] = ms[msp]
            end
            msp = limit
            @_END_ACC
        @end

        @define ACC_TABLE arg1 arg2
            --- Unstack all until main stack frame begin
            --- Make a table from it
            --- Unstack 1, a hash table
            --- Add keys to the table
            --- Stack the table
            --- Unstack main stack frame
            --- arg1: Number of slots to reserve for hash part
            --- arg2: -
            limit = msf[msfp]+1
            x = table.new(msp-limit+1, $arg1)
            for i=1, msp-limit+1 do
                x[i] = ms[limit+i-1]
            end
            for k, v in pairs(ms[limit-1]) do
                x[k] = v
            end
            ms[limit-1] = x
            msp = limit - 1
            @_END_ACC
        @end

        @define ACC_EMPTY arg1 arg2
            --- Stack 1 constant empty
            --- Unstack main stack frame
            --- arg1: -
            --- arg2: -
            msp = msp+1
            ms[msp] = plume.obj.empty
            @_END_ACC
        @end

        -----------
        -- TABLE --
        -----------
        @define TABLE_NEW arg1 arg2
            --- Stack 1 table
            --- arg1: -
            --- arg2: -
            msp = msp + 1
            ms[msp] = table.new(0, $arg1)
        @end

        @define TABLE_ADD arg1 arg2
        @end

        @define TABLE_INDEX arg1 arg2
            --- Unstack 2, in order: table, key
            --- Stack 1, table[key]
            --- arg1: -
            --- arg2: -
            ms[msp-1] = ms[msp][ms[msp-1]]
            msp = msp-1
        @end

        @define TABLE_SET arg1 arg2
            --- Unstack 3, in order: table, key, value
            --- Set the table.key to value
            --- arg1: -
            --- arg2: -
            ms[msp-2][ms[msp-1]] = ms[msp]
            msp = msp-3
        @end

        @define TABLE_SET_ACC arg1 arg2
            --- Unstack 2: a key, then a value
            --- Assume the main stack frame first value is a table
            --- Set the table.key to value
            --- arg1: -
            --- arg2: -
            ms[msf[msfp]][ms[msp]] = ms[msp-1]
            msp = msp-2
        @end

        ---------
        -- ALU --
        ---------
        -- binary calc
        @define _CHECK_NUMBER x
            if _type($x) == "string" then
                $x = tonumber($x)
            elseif _type($x) ~= "number" then
                @_ERROR {{"Cannot do comparison or arithmetic with " .. _type($x).. " value."}}
            end
        @end

        @define _BIN_OPP opp
            --- Classic opperations
            --- Unstack 2
            --- Stack 1, the result
            --- arg1: -
            --- arg2: -
            x = ms[msp-1]
            y = ms[msp]

            @_CHECK_NUMBER x
            @_CHECK_NUMBER y

            msp = msp-1
            ms[msp] = x $opp y
        @end

        @define _BIN_OPP_nc opp
            --- Classic opperations
            --- Unstack 2
            --- Stack 1, the result
            --- arg1: -
            --- arg2: -

            msp = msp-1
            ms[msp] = ms[msp] $opp ms[msp+1]
        @end

        @define _UN_OPP opp
            --- Classic opperations
            --- Unstack 1
            --- Stack 1, the result
            --- arg1: -
            --- arg2: -
            x = ms[msp]

            @_CHECK_NUMBER x

            ms[msp] = $opp y
        @end

        @define _UN_OPP_nc opp
            --- Classic opperations
            --- Unstack 1
            --- Stack 1, the result
            --- arg1: -
            --- arg2: -

            ms[msp] = $opp ms[msp]
        @end

        @define OPP_ADD @_BIN_OPP + @end
        @define OPP_SUB @_BIN_OPP - @end
        @define OPP_MUL @_BIN_OPP * @end
        @define OPP_DIV @_BIN_OPP / @end
        @define OPP_MOD @_BIN_OPP % @end
        @define OPP_POW @_BIN_OPP ^ @end
        @define OPP_NEG @_UN_OPP  - @end
        
        -- comp
        @define OPP_GTE  @_BIN_OPP >= @end
        @define OPP_LTE  @_BIN_OPP <= @end
        @define OPP_GT   @_BIN_OPP >  @end
        @define OPP_LT   @_BIN_OPP <  @end
        @define OPP_EQ   @_BIN_OPP == @end
        @define OPP_NEQ  @_BIN_OPP ~= @end

        -- bool
        @define OPP_AND  @_BIN_OPP_nc and @end
        @define OPP_OR   @_BIN_OPP_nc or  @end
        @define OPP_NOT  @_UN_OPP_nc  not @end

        -----------
        -- Jumps --
        -----------
        @define JUMP arg1 arg2
            --- Jump to offset
            --- arg1: -
            --- arg2: target offset
            jump = arg2
        @end
        @define JUMP_IF arg1 arg2
            --- Unstack 1
            --- Jump to offset if true
            --- arg1: -
            --- arg2: target offset
            if ms[msp] then
                jump = arg2
            end
            msp = msp-1
        @end
        @define JUMP_IF_NOT arg1 arg2
            --- Unstack 1
            --- Jump to offset if false
            --- arg1: -
            --- arg2: target offset
            if not ms[msp] then
                jump = $arg2
            end
            msp = msp-1
        @end
        @define JUMP_IF_NOT_EMPTY arg1 arg2
            --- Unstack 1
            --- Jump to offset if not empty
            --- Used by macro when setting defaut values
            --- arg1: -
            --- arg2: target offset
            if ms[msp] ~= plume.obj.empty then
                jump = $arg2
            end
            msp = msp-1
        @end

        ------------
        -- SCOPES --
        ------------
        @define ENTER_SCOPE arg1 arg2
            --- Reserve slots for locals variables and save scope begin offset
            --- Stack 1 to frame
            --- Stack 1 empty for each non already allocated variable
            --- arg1: Number of local variables already stacked
            --- arg2: Number of local variables
            vsfp = vsfp+1
            vsf[vsfp] = vsp+1-$arg1

            for i = 1, $arg2-$arg1 do
                vsp = vsp+1
                vs[vsp] = plume.obj.empty
            end
        @end

        @define LEAVE_SCOPE arg1 arg2
            --- Unstack 1 from vsf
            --- Remove all local variables
            --- arg1: -
            --- arg2: -
            vsp = vsf[vsfp]-1
            vsfp = vsfp-1
        @end

        @define ENTER_FILE arg1 arg2
            --- Present in each file/macro beginning.
            --- Serve to link STATIC_STORE/STATIC_LOAD to
            --- correct static memory
            --- Stack 1 to memory, the current file index
            --- arg1: -
            --- arg2: Fileid
            mp = mp+1
            memory[mp] = $arg2
        @end

        @define LEAVE_FILE arg1 arg2
            --- Unstack 1 to memory
            --- arg1: -
            --- arg2: -
            mp = mp-1
        @end

        @define NULL arg1 arg2
            --- Do nothing
            --- arg1: -
            --- arg2: -
        @end
            
        --==============--
        -- Main Program --
        --==============--

        -- All elseif-goto and labels are
        -- generated from OP_CODE liste (utils.lua)
        ::DISPATCH::
            @_START
            @_DECODING
            @_DISPATCH
            @_INSTRUCTIONS

        return true, ms[1], ip
    end
end