--[[This file is part of Plume

PlumeðŸª¶ is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

PlumeðŸª¶ is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with PlumeðŸª¶.
If not, see <https://www.gnu.org/licenses/>.
]]

-- Writed in my custom dirty preprocessor langage

-- More informations: /doc/vm.md

return function (plume)
    function plume.run(runtime)
        local empty  = plume.obj.empty
        local ptable = plume.obj.table

        local function _type(x)
            local t = type(x)
            if t=="table" then
                if x==empty then
                    return "empty"
                else
                    return x.type or x[1]
                end
            else
                return t
            end
        end

        --=====================--
        -- Instruction format --
        --=====================--
        local bit = require("bit")
        local OP_BITS   = 7
        local ARG1_BITS = 5
        local ARG2_BITS = 20
        local ARG1_SHIFT = ARG2_BITS
        local OP_SHIFT   = ARG1_BITS + ARG2_BITS
        local MASK_OP   = bit.lshift(1, OP_BITS) - 1
        local MASK_ARG1 = bit.lshift(1, ARG1_BITS) - 1
        local MASK_ARG2 = bit.lshift(1, ARG2_BITS) - 1

        --================--
        -- Initalization --
        --===============--
        require("table.new")

        local bytecode    = runtime.bytecode
        local constants   = runtime.constants
        local filesMemory = runtime.filesMemory

        local ip      = 0 -- instruction pointer
        local tic     = 0 -- total instruction count

        local ms   = table.new(2^14, 0) -- main stack
        local msf  = table.new(2^8, 0)  -- main stack frames (accumulators)
        local msp  = 0                  -- pointers
        local msfp = 0

        local vs   = table.new(2^10, 0)  -- variables stack
        local vsf  = table.new(2^8, 0)   -- variables stack frames (lexical scope)
        local vsp  = 0                   -- pointers
        local vsfp = 0

        local calls   = table.new(2^8, 0)  -- return from functions
        local cp      = 0 -- call pointer
        local memory  = table.new(2^8, 0)  -- return from files
                                           -- (not offsets, handled by functions,
                                           -- but static memory pointer)
        local mp      = 0 -- file memory pointer
        
        local jump    = 0 -- easier debuging than setting ip
        local instr, op, arg1, arg2 = 0, 0, 0, 0

        -- utils
        local limit = 0
        local macro, x, y 

        --debug
        local hook = plume.hook

        -----------
        -- ERROR -- 
        -----------
        @define _ERROR msg
            return false, $msg, ip
        @end

        ----------------
        -- LOOP ENTRY -- 
        ----------------
        @define _START
            if hook then
                if ip>0 then
                    hook(
                        tic, ip, jump,
                        instr, op, arg1, arg2,
                        ms, msp, msf, msfp,
                        vs, vsp, vsf, vsfp,
                        calls, cp,
                        memory, mp
                    )
                end
            end

            if jump>0 then
                ip = jump
                jump = 0-- 0 instead of nil to preserve type
            else
                ip = ip+1
            end
            tic = tic+1
        @end

        @define _DECODING
            instr = bytecode[ip]
            op    = bit.band(bit.rshift(instr, OP_SHIFT), MASK_OP)
            arg1  = bit.band(bit.rshift(instr, ARG1_SHIFT), MASK_ARG1)
            arg2  = bit.band(instr, MASK_ARG2)
        @end

        --=============--
        -- All OpCodes --
        --=============--

        ------------------
        -- LOAD / STORE --
        ------------------
        -- Constants
        @define LOAD_CONSTANT arg1 arg2
            --- Stack 1 from constant
            --- arg1: -
            --- arg2: constant offset
            msp = msp+1
            ms[msp] = constants[$arg2]
        @end

        @define LOAD_EMPTY arg1 arg2
            --- Stack 1 constant empty
            --- arg1: -
            --- arg2: -
            msp = msp+1
            ms[msp] = empty
        @end

        @define LOAD_TRUE arg1 arg2
            --- Stack 1 constant true
            --- arg1: -
            --- arg2: -
            msp = msp+1
            ms[msp] = true
        @end

        @define LOAD_FALSE arg1 arg2
            --- Stack 1 constant false
            --- arg1: -
            --- arg2: -
            msp = msp+1
            ms[msp] = false
        @end

        
        -- Variables
        @define LOAD_LOCAL arg1 arg2
            --- Stack 1 from vs.
            --- Final offset: current frame + vs offset
            --- arg1: -
            --- arg2: vs offset
            msp = msp+1
            ms[msp] = vs[vsf[vsfp] + $arg2-1]
        @end

        @define LOAD_LEXICAL arg1 arg2
            --- Stack 1 from vs.
            --- Final offset: the nth last frame + vs offset
            --- arg1: frame offset
            --- arg2: vs offset
            msp = msp+1
            ms[msp] = vs[vsf[vsfp-arg1]+$arg2-1]
        @end

        @define LOAD_STATIC arg1 arg2
            --- Stack 1 from static memory
            --- memory[mp] is a pointer to the current
            --- file intern memory
            --- arg1: -
            --- arg2: vs offset
            msp = msp+1
            ms[msp] = filesMemory[memory[mp]][$arg2]
        @end

        @define STORE_LOCAL arg1 arg2
            --- Unstack 1 to vs
            --- Final offset: current frame + frame offset
            --- arg1: -
            --- arg2: frame offset
            vs[vsf[vsfp] + $arg2-1] = ms[msp]
            msp = msp-1
        @end

        @define STORE_LEXICAL arg1 arg2
            --- Unstack 1 to vs
            --- Offset: the anth last frame + frame offset
            --- arg1: frame offset
            --- arg2: frame offset
            vs[vsf[vsfp-$arg1]+$arg2-1] = ms[msp]
            msp = msp-1
        @end

        @define STORE_STATIC arg1 arg2
            --- Unstack 1 static memory
            --- memory[mp] is a pointer to the current
            --- file intern memory
            --- arg1: -
            --- arg2: frame offset
            filesMemory[memory[mp]][$arg2] = ms[msp]
            msp = msp-1
        @end

        ----------
        -- For --
        ----------
        @define GET_ITER
            --- Unstack 1 iterable object
            --- Stack 1 iterator object
            --- arg1: -
            --- arg2: -
            local obj = ms[msp]
            local tobj = _type(obj)
            if tobj ~= "table" then
                @_ERROR{{"Try to iterate over a non-table '" .. tobj .. "' object."}}
            end

            ms[msp] = obj.meta.iter.callable() -- 4: meta table 2: data
        @end

        @define FOR_ITER arg1 arg2
            --- Unstack 1 iterator object
            --- Stack 1 next call result OR jump to for end
            --- arg1: -
            --- arg2: jump to end for
            local result = ms[msp].table.next.callable()
            if result == empty then
                msp = msp-1
                @JUMP 0 $arg1
            else
                ms[msp] = result
            end
        @end

        ----------
        -- Call --
        ----------
        @define _UNSTACK_POS
            local argcount = msp-msf[msfp]
            if argcount ~= macro.positionalParamCount and macro.variadicOffset==0 then
                @_ERROR{{"Wrong number of positionnal arguments for macro '" .. macro.name.. "', " ..   argcount .. " instead of " .. macro.positionalParamCount}}
            end

            for i=1, macro.positionalParamCount do
                vs[vsf[vsfp]+i-1] = ms[msp+i-argcount]
            end

            for i=macro.positionalParamCount+1, argcount do
                table.insert(capture.table, ms[msp+i-argcount])
            end

            msp = msf[msfp]
        @end

        @define _UNSTACK_NAMED
            for i=1, #ms[msf[msfp]], 2 do
                local k=ms[msf[msfp]][i]
                local v=ms[msf[msfp]][i+1]
                local j = macro.namedParamOffset[k]

                if j then
                    vs[vsf[vsfp]+j-1] = v
                elseif macro.variadicOffset>0 then
                    @_TABLE_SET capture k v
                else
                    @_ERROR{{"Unknow named parameter '" .. k .."' for macro '" .. macro.name .."'."}}
                end
            end    
            msp = msp-1
        @end

        @define ACC_CALL arg1 arg2
            --- Unstack 1 (the macro)
            --- Unstack until frame begin + 1 (all positionals arguments)
            --- Unstack 1 (table of named arguments)
            --- Create a new scope
            --- Stack all arguments to varstack
            --- Set jump to macro offset
            --- Stack current ip to calls
            --- arg1: -
            --- arg2: -
            macro = ms[msp]
            msp = msp - 1
            local t = _type(macro)
            if t == "macro" then
                @ENTER_SCOPE 0 macro.positionalParamCount+macro.namedParamCount
                local capture
                if macro.variadicOffset>0 then -- variadic
                    capture = ptable(0, 0) -- can be optimized
                end
                @_UNSTACK_POS
                @_UNSTACK_NAMED
                if macro.variadicOffset>0 then -- variadic
                    vs[macro.variadicOffset] = capture
                end
                @_END_ACC
                jump = macro.offset
                cp = cp + 1
                calls[cp] = ip+1
            elseif t == "luaFunction" then
                @ACC_TABLE
                local result = macro.callable(ms[msp])
                if result == nil then
                    result = empty
                end
                ms[msp] = result
            else
                @_ERROR {{"Try to call a '" .. t .. "' value"}}
            end
        @end
        
        @define RETURN arg1 arg2
            --- Unstack 1 from calls
            --- Set jump to it
            --- Leave scope
            --- arg1: -
            --- arg2: -
            jump = calls[cp]
            if not jump then -- exit the main programm
                jump = #bytecode -- goto to END
            end
            cp = cp - 1
            @LEAVE_SCOPE 0 0
            @LEAVE_FILE
        @end

        ---------
        -- ACC --
        ---------
        @define BEGIN_ACC arg1 arg2
            --- Stack 1 to main stack frame, the current msp
            --- arg1: -
            --- arg2: -
            msfp = msfp + 1
            msf[msfp] = msp+1
        @end

        @define _END_ACC arg1 arg2
            msfp = msfp-1
        @end

        @define ACC_TEXT arg1 arg2
            --- Unstack all until main stack frame begin
            --- Concat and main stack the result
            --- Unstack main stack frame
            --- arg1: -
            --- arg2: -
            limit = msf[msfp]
            --if msp-limit>=1 then
                for i=limit, msp do
                    if ms[i] == empty then
                        ms[i] = ""
                    end
                end
                ms[limit] = table.concat(ms, "", limit, msp)
            --elseif msp-limit==0 then -- so exactly 1 var
            --    ms[limit] = ms[msp]
            --else
            --    ms[limit] = empty
            --end
            msp = limit
            @_END_ACC
        @end

        @define ACC_TABLE arg1 arg2
            --- Unstack all until main stack frame begin
            --- Make a table from it
            --- Unstack 1, a hash table
            --- Add keys to the table
            --- Stack the table
            --- Unstack main stack frame
            --- arg1: -
            --- arg2: -
            limit = msf[msfp]+1 -- Count items
            local keyCount = #ms[limit-1] / 2
            local args = ptable(msp-limit+1, keyCount)
            for i=1, msp-limit+1 do -- dump items
                args.table[i] = ms[limit+i-1]
            end
            for i=1, #ms[limit-1], 2 do --dump keys 
                @_TABLE_SET args ms[limit-1][i] ms[limit-1][i+1]
            end
            ms[limit-1] = args
            msp = limit - 1
            @_END_ACC
        @end

        @define ACC_EMPTY arg1 arg2
            --- Stack 1 constant empty
            --- Unstack main stack frame
            --- arg1: -
            --- arg2: -
            msp = msp+1
            ms[msp] = empty
            @_END_ACC
        @end

        -----------
        -- TABLE --
        -----------
        @define TABLE_NEW arg1 arg2
            --- Stack 1 table
            --- arg1: -
            --- arg2: -
            msp = msp + 1
            ms[msp] = table.new(0, $arg1)
        @end

        @define TABLE_ADD arg1 arg2
        @end

        @define TABLE_INDEX arg1 arg2
            --- Unstack 2, in order: table, key
            --- Stack 1, table[key]
            --- arg1: -
            --- arg2: -
            ms[msp-1] = ms[msp].table[ms[msp-1]]
            msp = msp-1
        @end

        @define TABLE_INDEX_META arg1 arg2
            --- Unstack 2, in order: table, key
            --- Stack 1, table[key]
            --- arg1: -
            --- arg2: -
            ms[msp-1] = ms[msp].meta[ms[msp-1]]
            msp = msp-1
        @end

        @define _TABLE_SET t k v
            -- if dont exists, register key
            if not $t.table[$k] then
                table.insert($t.keys, $k)
            end
            $t.table[$k] = $v --set
        @end

        @define TABLE_SET arg1 arg2
            --- Unstack 3, in order: table, key, value
            --- Set the table.key to value
            --- arg1: -
            --- arg2: -
            ms[msp-2].table[ms[msp-1]] = ms[msp]
            msp = msp-3
        @end

        @define TABLE_SET_META arg1 arg2
            --- Unstack 3, in order: table, key, value
            --- Set the table.key to value
            --- arg1: -
            --- arg2: -
            ms[msp-2].meta[ms[msp-1]] = ms[msp]
            msp = msp-3
        @end

        @define TABLE_SET_ACC arg1 arg2
            --- Unstack 2: a key, then a value
            --- Assume the main stack frame first value is a table
            --- Register key, then value in
            --- arg1: -
            --- arg2: -
            table.insert(ms[msf[msfp]], ms[msp])
            table.insert(ms[msf[msfp]], ms[msp-1])
            msp = msp-2
        @end

        @define TABLE_EXPAND arg1 arg2
            --- Unstack 1: a table
            --- Stack all list item
            --- Put all hash item on the acc table
            --- arg1: -
            --- arg2: -
            local t = ms[msp]
            msp = msp-1
            for _, item in ipairs(t.table) do
                msp = msp+1
                ms[msp] = item
            end
            for _, key in ipairs(t.keys) do
                table.insert(ms[msf[msfp]], key)
                table.insert(ms[msf[msfp]], t.table[key])
            end
        @end

        ---------
        -- ALU --
        ---------
        -- binary calc
        @define _CHECK_NUMBER x
            if _type($x) == "string" then
                $x = tonumber($x)
            elseif _type($x) ~= "number" then
                @_ERROR {{"Cannot do comparison or arithmetic with " .. _type($x).. " value."}}
            end
        @end

        @define _CHECK_BOOL x
            if $x == empty then
                $x = false
            end
        @end

        @define _BIN_OPP opp check
            --- Classic opperations
            --- Unstack 2
            --- Stack 1, the result
            --- arg1: -
            --- arg2: -
            x = ms[msp-1]
            y = ms[msp]

            @_CHECK_$check x
            @_CHECK_$check y

            msp = msp-1
            ms[msp] = x $opp y
        @end

        @define _UN_OPP opp check
            --- Classic opperations
            --- Unstack 1
            --- Stack 1, the result
            --- arg1: -
            --- arg2: -
            x = ms[msp]

            @_CHECK_$check x

            ms[msp] = $opp x
        @end


        @define OPP_ADD @_BIN_OPP + NUMBER @end
        @define OPP_SUB @_BIN_OPP - NUMBER @end
        @define OPP_MUL @_BIN_OPP * NUMBER @end
        @define OPP_DIV @_BIN_OPP / NUMBER @end
        @define OPP_MOD @_BIN_OPP % NUMBER @end
        @define OPP_POW @_BIN_OPP ^ NUMBER @end
        @define OPP_NEG @_UN_OPP  - NUMBER @end
        
        -- comp
        @define OPP_GTE  @_BIN_OPP >= NUMBER @end
        @define OPP_LTE  @_BIN_OPP <= NUMBER @end
        @define OPP_GT   @_BIN_OPP >  NUMBER @end
        @define OPP_LT   @_BIN_OPP <  NUMBER @end
        @define OPP_EQ   @_BIN_OPP == NUMBER @end
        @define OPP_NEQ  @_BIN_OPP ~= NUMBER @end

        -- bool
        @define OPP_AND  @_BIN_OPP and BOOL @end
        @define OPP_OR   @_BIN_OPP or  BOOL @end
        @define OPP_NOT  @_UN_OPP  not BOOL @end

        -----------
        -- Jumps --
        -----------
        @define JUMP arg1 arg2
            --- Jump to offset
            --- arg1: -
            --- arg2: target offset
            jump = arg2
        @end
        @define JUMP_IF arg1 arg2
            --- Unstack 1
            --- Jump to offset if true
            --- arg1: -
            --- arg2: target offset
            local test = ms[msp]
            @_CHECK_BOOL test
            if test then
                jump = arg2
            end
            msp = msp-1
        @end
        @define JUMP_IF_NOT arg1 arg2
            --- Unstack 1
            --- Jump to offset if false
            --- arg1: -
            --- arg2: target offset
            local test = ms[msp]
            @_CHECK_BOOL test
            if not test then
                jump = $arg2
            end
            msp = msp-1
        @end
        @define JUMP_IF_NOT_EMPTY arg1 arg2
            --- Unstack 1
            --- Jump to offset if not empty
            --- Used by macro when setting defaut values
            --- arg1: -
            --- arg2: target offset
            if ms[msp] ~= empty then
                jump = $arg2
            end
            msp = msp-1
        @end

        ------------
        -- SCOPES --
        ------------
        @define ENTER_SCOPE arg1 arg2
            --- Reserve slots for locals variables and save scope begin offset
            --- Stack 1 to frame
            --- Stack 1 empty for each non already allocated variable
            --- arg1: Number of local variables already stacked
            --- arg2: Number of local variables
            vsfp = vsfp+1
            vsf[vsfp] = vsp+1-$arg1

            for i = 1, $arg2-$arg1 do
                vsp = vsp+1
                vs[vsp] = empty
            end
        @end

        @define LEAVE_SCOPE arg1 arg2
            --- Unstack 1 from vsf
            --- Remove all local variables
            --- arg1: -
            --- arg2: -
            vsp = vsf[vsfp]-1
            vsfp = vsfp-1
        @end

        @define ENTER_FILE arg1 arg2
            --- Present in each file/macro beginning.
            --- Serve to link STATIC_STORE/STATIC_LOAD to
            --- correct static memory
            --- Stack 1 to memory, the current file index
            --- arg1: -
            --- arg2: Fileid
            mp = mp+1
            memory[mp] = $arg2
        @end

        @define LEAVE_FILE arg1 arg2
            --- Unstack 1 to memory
            --- arg1: -
            --- arg2: -
            mp = mp-1
        @end

        @define NULL arg1 arg2
            --- Do nothing
            --- arg1: -
            --- arg2: -
        @end
            
        --==============--
        -- Main Program --
        --==============--

        -- All elseif-goto and labels are
        -- generated from OP_CODE liste (utils.lua)
        ::DISPATCH::
            @_START
            @_DECODING
            @_DISPATCH
            @_INSTRUCTIONS

        return true, plume.std.tostring.callable({table={ms[1]}}), ip
    end
end