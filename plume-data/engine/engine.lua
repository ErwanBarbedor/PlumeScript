--File generated by preprocessor.lua
--[[This file is part of Plume
PlumeðŸª¶ is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.
PlumeðŸª¶ is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with PlumeðŸª¶.
If not, see <https://www.gnu.org/licenses/>.
]]
return function (plume)
    function plume.run(runtime)
        local empty=plume.obj.empty
        local ptable=plume.obj.table
        local function _type(x)
            local t=type(x)
            if t=="table" then
                if x==empty then
                    return "empty"
                else
                    return x.type or x[1]
                end
            else
                return t
            end
        end
        local bit=require("bit")
        local OP_BITS=7
        local ARG1_BITS=5
        local ARG2_BITS=20
        local ARG1_SHIFT=ARG2_BITS
        local OP_SHIFT=ARG1_BITS + ARG2_BITS
        local MASK_OP=bit.lshift(1, OP_BITS) - 1
        local MASK_ARG1=bit.lshift(1, ARG1_BITS) - 1
        local MASK_ARG2=bit.lshift(1, ARG2_BITS) - 1
        require("table.new")
        local bytecode=runtime.bytecode
        local constants=runtime.constants
        local filesMemory=runtime.filesMemory
        local ip=0
        local tic=0
        local ms=table.new(2^14, 0)
        local msf=table.new(2^8, 0)
        local msp=0
        local msfp=0
        local vs=table.new(2^10, 0)
        local vsf=table.new(2^8, 0)
        local vsp=0
        local vsfp=0
        local calls=table.new(2^8, 0)
        local cp=0
        local memory=table.new(2^8, 0)
        local mp=0
        local jump=0
        local instr, op, arg1, arg2=0, 0, 0, 0
        local limit=0
        local macro, x, y
        local hook=plume.hook
        ::DISPATCH::
                        	if hook then
                if ip>0 then
                    hook(
                        tic, ip, jump,
                        instr, op, arg1, arg2,
                        ms, msp, msf, msfp,
                        vs, vsp, vsf, vsfp,
                        calls, cp,
                        memory, mp
                    )
                end
            end
            if jump>0 then
                ip=jump
                jump=0
            else
                ip=ip+1
            end
            tic=tic+1
                        instr=bytecode[ip]
            op=bit.band(bit.rshift(instr, OP_SHIFT), MASK_OP)
            arg1=bit.band(bit.rshift(instr, ARG1_SHIFT), MASK_ARG1)
            arg2=bit.band(instr, MASK_ARG2)
            			if op==1 then goto LOAD_CONSTANT
			elseif op==2 then goto LOAD_TRUE
			elseif op==3 then goto LOAD_FALSE
			elseif op==4 then goto LOAD_EMPTY
			elseif op==5 then goto LOAD_LOCAL
			elseif op==6 then goto LOAD_LEXICAL
			elseif op==7 then goto LOAD_STATIC
			elseif op==8 then goto STORE_LOCAL
			elseif op==9 then goto STORE_LEXICAL
			elseif op==10 then goto STORE_STATIC
			elseif op==11 then goto TABLE_NEW
			elseif op==12 then goto TABLE_ADD
			elseif op==13 then goto TABLE_SET
			elseif op==14 then goto TABLE_INDEX
			elseif op==15 then goto TABLE_INDEX_ACC_SELF
			elseif op==16 then goto TABLE_SET_META
			elseif op==17 then goto TABLE_INDEX_META
			elseif op==18 then goto TABLE_SET_ACC
			elseif op==19 then goto TABLE_SET_ACC_META
			elseif op==20 then goto TABLE_EXPAND
			elseif op==21 then goto ENTER_SCOPE
			elseif op==22 then goto LEAVE_SCOPE
			elseif op==23 then goto ENTER_FILE
			elseif op==24 then goto LEAVE_FILE
			elseif op==25 then goto BEGIN_ACC
			elseif op==26 then goto ACC_TABLE
			elseif op==27 then goto ACC_TEXT
			elseif op==28 then goto ACC_EMPTY
			elseif op==29 then goto ACC_CALL
			elseif op==30 then goto RETURN
			elseif op==31 then goto JUMP_IF
			elseif op==32 then goto JUMP_IF_NOT
			elseif op==33 then goto JUMP_IF_NOT_EMPTY
			elseif op==34 then goto JUMP
			elseif op==35 then goto GET_ITER
			elseif op==36 then goto FOR_ITER
			elseif op==37 then goto OPP_ADD
			elseif op==38 then goto OPP_MUL
			elseif op==39 then goto OPP_SUB
			elseif op==40 then goto OPP_DIV
			elseif op==41 then goto OPP_NEG
			elseif op==42 then goto OPP_MOD
			elseif op==43 then goto OPP_POW
			elseif op==44 then goto OPP_GTE
			elseif op==45 then goto OPP_LTE
			elseif op==46 then goto OPP_GT
			elseif op==47 then goto OPP_LT
			elseif op==48 then goto OPP_EQ
			elseif op==49 then goto OPP_NEQ
			elseif op==50 then goto OPP_AND
			elseif op==51 then goto OPP_NOT
			elseif op==52 then goto OPP_OR
			elseif op==53 then goto DUPLICATE
			elseif op==54 then goto END
			end
            			::LOAD_CONSTANT::
	do
	            msp=msp+1
	            ms[msp]=constants[arg2]
				goto DISPATCH
end
			::LOAD_TRUE::
	do
	            msp=msp+1
	            ms[msp]=true
				goto DISPATCH
end
			::LOAD_FALSE::
	do
	            msp=msp+1
	            ms[msp]=false
				goto DISPATCH
end
			::LOAD_EMPTY::
	do
	            msp=msp+1
	            ms[msp]=empty
				goto DISPATCH
end
			::LOAD_LOCAL::
	do
	            msp=msp+1
	            ms[msp]=vs[vsf[vsfp] + arg2-1]
				goto DISPATCH
end
			::LOAD_LEXICAL::
	do
	            msp=msp+1
	            ms[msp]=vs[vsf[vsfp-arg1]+arg2-1]
				goto DISPATCH
end
			::LOAD_STATIC::
	do
	            msp=msp+1
	            ms[msp]=filesMemory[memory[mp]][arg2]
				goto DISPATCH
end
			::STORE_LOCAL::
	do
	            vs[vsf[vsfp] + arg2-1]=ms[msp]
	            msp=msp-1
				goto DISPATCH
end
			::STORE_LEXICAL::
	do
	            vs[vsf[vsfp-arg1]+arg2-1]=ms[msp]
	            msp=msp-1
				goto DISPATCH
end
			::STORE_STATIC::
	do
	            filesMemory[memory[mp]][arg2]=ms[msp]
	            msp=msp-1
				goto DISPATCH
end
			::TABLE_NEW::
	do
	            msp=msp + 1
	            ms[msp]=table.new(0, arg1)
				goto DISPATCH
end
			::TABLE_ADD::
	do
				goto DISPATCH
end
			::TABLE_SET::
	do
	            ms[msp].table[ms[msp-1]]=ms[msp-2]
	            msp=msp-3
				goto DISPATCH
end
			::TABLE_INDEX::
	do
	            ms[msp-1]=ms[msp].table[ms[msp-1]]
	            msp=msp-1
				goto DISPATCH
end
			::TABLE_INDEX_ACC_SELF::
	do
	            table.insert(ms[msf[msfp]], "self")
	            table.insert(ms[msf[msfp]], ms[msp])
	            table.insert(ms[msf[msfp]], false)
	                        ms[msp-1]=ms[msp].table[ms[msp-1]]
	            msp=msp-1
				goto DISPATCH
end
			::TABLE_SET_META::
	do
	            ms[msp-2].meta[ms[msp-1]]=ms[msp]
	            msp=msp-3
				goto DISPATCH
end
			::TABLE_INDEX_META::
	do
	            ms[msp-1]=ms[msp].meta[ms[msp-1]]
	            msp=msp-1
				goto DISPATCH
end
			::TABLE_SET_ACC::
	do
	            table.insert(ms[msf[msfp]], ms[msp])
	            table.insert(ms[msf[msfp]], ms[msp-1])
	            table.insert(ms[msf[msfp]], false)
	            msp=msp-2
				goto DISPATCH
end
			::TABLE_SET_ACC_META::
	do
	            table.insert(ms[msf[msfp]], ms[msp])
	            table.insert(ms[msf[msfp]], ms[msp-1])
	            table.insert(ms[msf[msfp]], true)
	            msp=msp-2
				goto DISPATCH
end
			::TABLE_EXPAND::
	do
	            local t=ms[msp]
	            msp=msp-1
	            for _, item in ipairs(t.table) do
	                msp=msp+1
	                ms[msp]=item
	            end
	            for _, key in ipairs(t.keys) do
	                table.insert(ms[msf[msfp]], key)
	                table.insert(ms[msf[msfp]], t.table[key])
	                table.insert(ms[msf[msfp]], false)
	            end
				goto DISPATCH
end
			::ENTER_SCOPE::
	do
	            vsfp=vsfp+1
	            vsf[vsfp]=vsp+1-arg1
	            for i=1, arg2-arg1 do
	                vsp=vsp+1
	                vs[vsp]=empty
	            end
				goto DISPATCH
end
			::LEAVE_SCOPE::
	do
	            vsp=vsf[vsfp]-1
	            vsfp=vsfp-1
				goto DISPATCH
end
			::ENTER_FILE::
	do
	            mp=mp+1
	            memory[mp]=arg2
				goto DISPATCH
end
			::LEAVE_FILE::
	do
	            mp=mp-1
				goto DISPATCH
end
			::BEGIN_ACC::
	do
	            msfp=msfp + 1
	            msf[msfp]=msp+1
				goto DISPATCH
end
			::ACC_TABLE::
	do
	            limit=msf[msfp]+1
	            local keyCount=#ms[limit-1] / 2
	            local args=ptable(msp-limit+1, keyCount)
	            for i=1, msp-limit+1 do
	                args.table[i]=ms[limit+i-1]
	            end
	            for i=1, #ms[limit-1], 3 do
	                if ms[limit-1][i+2] then
	                                args.meta[ms[limit-1][i]]=ms[limit-1][i+1]
	                else
	                                if not args.table[ms[limit-1][i]] then
	                table.insert(args.keys, ms[limit-1][i])
	            end
	            args.table[ms[limit-1][i]]=ms[limit-1][i+1]
	                end
	            end
	            ms[limit-1]=args
	            msp=limit - 1
	                        msfp=msfp-1
				goto DISPATCH
end
			::ACC_TEXT::
	do
	            limit=msf[msfp]
	                for i=limit, msp do
	                    if ms[i]==empty then
	                        ms[i]=""
	                    end
	                end
	                ms[limit]=table.concat(ms, "", limit, msp)
	            msp=limit
	                        msfp=msfp-1
				goto DISPATCH
end
			::ACC_EMPTY::
	do
	            msp=msp+1
	            ms[msp]=empty
	                        msfp=msfp-1
				goto DISPATCH
end
			::ACC_CALL::
	do
	            macro=ms[msp]
	            msp=msp - 1
	            local t=_type(macro)
	            if t=="macro" then
	                            vsfp=vsfp+1
	            vsf[vsfp]=vsp+1-0
	            for i=1, macro.localsCount-0 do
	                vsp=vsp+1
	                vs[vsp]=empty
	            end
	                local capture
	                if macro.variadicOffset>0 then
	                    capture=ptable(0, 0)
	                end
	                            local argcount=msp-msf[msfp]
	            if argcount ~=macro.positionalParamCount and macro.variadicOffset==0 then
	                            return false, "Wrong number of positionnal arguments for macro '" .. macro.name.. "', " ..   argcount .. " instead of " .. macro.positionalParamCount, ip
	            end
	            for i=1, macro.positionalParamCount do
	                vs[vsf[vsfp]+i-1]=ms[msp+i-argcount]
	            end
	            for i=macro.positionalParamCount+1, argcount do
	                table.insert(capture.table, ms[msp+i-argcount])
	            end
	            msp=msf[msfp]
	                            for i=1, #ms[msf[msfp]], 3 do
	                local k=ms[msf[msfp]][i]
	                local v=ms[msf[msfp]][i+1]
	                local m=ms[msf[msfp]][i+2]
	                local j=macro.namedParamOffset[k]
	                if m then
	                                capture.meta[k]=v
	                elseif j then
	                    vs[vsf[vsfp]+j-1]=v
	                elseif macro.variadicOffset>0 then
	                                if not capture.table[k] then
	                table.insert(capture.keys, k)
	            end
	            capture.table[k]=v
	                else
	                                return false, "Unknow named parameter '" .. k .."' for macro '" .. macro.name .."'.", ip
	                end
	            end
	            msp=msp-1
	                if macro.variadicOffset>0 then
	                    vs[vsf[vsfp]+macro.variadicOffset-1]=capture
	                end
	                            msfp=msfp-1
	                jump=macro.offset
	                cp=cp + 1
	                calls[cp]=ip+1
	            elseif t=="luaFunction" then
	                            limit=msf[msfp]+1
	            local keyCount=#ms[limit-1] / 2
	            local args=ptable(msp-limit+1, keyCount)
	            for i=1, msp-limit+1 do
	                args.table[i]=ms[limit+i-1]
	            end
	            for i=1, #ms[limit-1], 3 do
	                if ms[limit-1][i+2] then
	                                args.meta[ms[limit-1][i]]=ms[limit-1][i+1]
	                else
	                                if not args.table[ms[limit-1][i]] then
	                table.insert(args.keys, ms[limit-1][i])
	            end
	            args.table[ms[limit-1][i]]=ms[limit-1][i+1]
	                end
	            end
	            ms[limit-1]=args
	            msp=limit - 1
	                        msfp=msfp-1
	                local result, isJump=macro.callable(ms[msp], runtime)
	                if isJump then
	                    jump=result
	                    cp=cp + 1
	                    calls[cp]=ip+1
	                    msp=msp - 1
	                else
	                    if result==nil then
	                        result=empty
	                    end
	                    ms[msp]=result
	                end
	            else
	                            return false, "Try to call a '" .. t .. "' value", ip
	            end
				goto DISPATCH
end
			::RETURN::
	do
	            jump=calls[cp]
	            if not jump then
	                jump=#bytecode
	            end
	            cp=cp - 1
	                        vsp=vsf[vsfp]-1
	            vsfp=vsfp-1
	                        mp=mp-1
				goto DISPATCH
end
			::JUMP_IF::
	do
	            local test=ms[msp]
	                        if test==empty then
	                test=false
	            end
	            if test then
	                jump=arg2
	            end
	            msp=msp-1
				goto DISPATCH
end
			::JUMP_IF_NOT::
	do
	            local test=ms[msp]
	                        if test==empty then
	                test=false
	            end
	            if not test then
	                jump=arg2
	            end
	            msp=msp-1
				goto DISPATCH
end
			::JUMP_IF_NOT_EMPTY::
	do
	            if ms[msp] ~=empty then
	                jump=arg2
	            end
	            msp=msp-1
				goto DISPATCH
end
			::JUMP::
	do
	            jump=arg2
				goto DISPATCH
end
			::GET_ITER::
	do
	            local obj=ms[msp]
	            local tobj=_type(obj)
	            if tobj ~="table" then
	                            return false, "Try to iterate over a non-table '" .. tobj .. "' object.", ip
	            end
	            local iter=obj.meta.iter
	            if iter.type=="luaFunction" then
	                ms[msp]=iter.callable()
	            elseif iter.type=="macro" then
	                jump=iter.offset
	                cp=cp + 1
	                calls[cp]=ip+1
	            end
				goto DISPATCH
end
			::FOR_ITER::
	do
	            local result=ms[msp].table.next.callable()
	            if result==empty then
	                msp=msp-1
	                            jump=arg2
	            else
	                ms[msp]=result
	            end
				goto DISPATCH
end
			::OPP_ADD::
	do
	            x=ms[msp-1]
	            y=ms[msp]
	                        if _type(x)=="string" then
	                x=tonumber(x)
	            elseif _type(x) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(x).. " value.", ip
	            end
	                        if _type(y)=="string" then
	                y=tonumber(y)
	            elseif _type(y) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(y).. " value.", ip
	            end
	            msp=msp-1
	            ms[msp]=x + y
				goto DISPATCH
end
			::OPP_MUL::
	do
	            x=ms[msp-1]
	            y=ms[msp]
	                        if _type(x)=="string" then
	                x=tonumber(x)
	            elseif _type(x) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(x).. " value.", ip
	            end
	                        if _type(y)=="string" then
	                y=tonumber(y)
	            elseif _type(y) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(y).. " value.", ip
	            end
	            msp=msp-1
	            ms[msp]=x * y
				goto DISPATCH
end
			::OPP_SUB::
	do
	            x=ms[msp-1]
	            y=ms[msp]
	                        if _type(x)=="string" then
	                x=tonumber(x)
	            elseif _type(x) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(x).. " value.", ip
	            end
	                        if _type(y)=="string" then
	                y=tonumber(y)
	            elseif _type(y) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(y).. " value.", ip
	            end
	            msp=msp-1
	            ms[msp]=x - y
				goto DISPATCH
end
			::OPP_DIV::
	do
	            x=ms[msp-1]
	            y=ms[msp]
	                        if _type(x)=="string" then
	                x=tonumber(x)
	            elseif _type(x) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(x).. " value.", ip
	            end
	                        if _type(y)=="string" then
	                y=tonumber(y)
	            elseif _type(y) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(y).. " value.", ip
	            end
	            msp=msp-1
	            ms[msp]=x / y
				goto DISPATCH
end
			::OPP_NEG::
	do
	            x=ms[msp]
	                        if _type(x)=="string" then
	                x=tonumber(x)
	            elseif _type(x) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(x).. " value.", ip
	            end
	            ms[msp]=- x
				goto DISPATCH
end
			::OPP_MOD::
	do
	            x=ms[msp-1]
	            y=ms[msp]
	                        if _type(x)=="string" then
	                x=tonumber(x)
	            elseif _type(x) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(x).. " value.", ip
	            end
	                        if _type(y)=="string" then
	                y=tonumber(y)
	            elseif _type(y) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(y).. " value.", ip
	            end
	            msp=msp-1
	            ms[msp]=x % y
				goto DISPATCH
end
			::OPP_POW::
	do
	            x=ms[msp-1]
	            y=ms[msp]
	                        if _type(x)=="string" then
	                x=tonumber(x)
	            elseif _type(x) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(x).. " value.", ip
	            end
	                        if _type(y)=="string" then
	                y=tonumber(y)
	            elseif _type(y) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(y).. " value.", ip
	            end
	            msp=msp-1
	            ms[msp]=x ^ y
				goto DISPATCH
end
			::OPP_GTE::
	do
	            x=ms[msp-1]
	            y=ms[msp]
	                        if _type(x)=="string" then
	                x=tonumber(x)
	            elseif _type(x) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(x).. " value.", ip
	            end
	                        if _type(y)=="string" then
	                y=tonumber(y)
	            elseif _type(y) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(y).. " value.", ip
	            end
	            msp=msp-1
	            ms[msp]=x >=y
				goto DISPATCH
end
			::OPP_LTE::
	do
	            x=ms[msp-1]
	            y=ms[msp]
	                        if _type(x)=="string" then
	                x=tonumber(x)
	            elseif _type(x) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(x).. " value.", ip
	            end
	                        if _type(y)=="string" then
	                y=tonumber(y)
	            elseif _type(y) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(y).. " value.", ip
	            end
	            msp=msp-1
	            ms[msp]=x <=y
				goto DISPATCH
end
			::OPP_GT::
	do
	            x=ms[msp-1]
	            y=ms[msp]
	                        if _type(x)=="string" then
	                x=tonumber(x)
	            elseif _type(x) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(x).. " value.", ip
	            end
	                        if _type(y)=="string" then
	                y=tonumber(y)
	            elseif _type(y) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(y).. " value.", ip
	            end
	            msp=msp-1
	            ms[msp]=x > y
				goto DISPATCH
end
			::OPP_LT::
	do
	            x=ms[msp-1]
	            y=ms[msp]
	                        if _type(x)=="string" then
	                x=tonumber(x)
	            elseif _type(x) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(x).. " value.", ip
	            end
	                        if _type(y)=="string" then
	                y=tonumber(y)
	            elseif _type(y) ~="number" then
	                            return false, "Cannot do comparison or arithmetic with " .. _type(y).. " value.", ip
	            end
	            msp=msp-1
	            ms[msp]=x < y
				goto DISPATCH
end
			::OPP_EQ::
	do
	            x=ms[msp-1]
	            y=ms[msp]
	                        if _type(x)=="string" then
	                x=tonumber(x) or x
	            end
	                        if _type(y)=="string" then
	                y=tonumber(y) or y
	            end
	            msp=msp-1
	            ms[msp]=x==y
				goto DISPATCH
end
			::OPP_NEQ::
	do
	            x=ms[msp-1]
	            y=ms[msp]
	                        if _type(x)=="string" then
	                x=tonumber(x) or x
	            end
	                        if _type(y)=="string" then
	                y=tonumber(y) or y
	            end
	            msp=msp-1
	            ms[msp]=x ~=y
				goto DISPATCH
end
			::OPP_AND::
	do
	            x=ms[msp-1]
	            y=ms[msp]
	                        if x==empty then
	                x=false
	            end
	                        if y==empty then
	                y=false
	            end
	            msp=msp-1
	            ms[msp]=x and y
				goto DISPATCH
end
			::OPP_NOT::
	do
	            x=ms[msp]
	                        if x==empty then
	                x=false
	            end
	            ms[msp]=not x
				goto DISPATCH
end
			::OPP_OR::
	do
	            x=ms[msp-1]
	            y=ms[msp]
	                        if x==empty then
	                x=false
	            end
	                        if y==empty then
	                y=false
	            end
	            msp=msp-1
	            ms[msp]=x or y
				goto DISPATCH
end
			::DUPLICATE::
	do
					goto DISPATCH
end
		::END::
        	return true, plume.std.tostring.callable({table={ms[1]}}), ip
    end
end