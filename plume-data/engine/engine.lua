--[[This file is part of Plume

PlumeðŸª¶ is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

PlumeðŸª¶ is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with PlumeðŸª¶.
If not, see <https://www.gnu.org/licenses/>.
]]

-- Generated by build-tools/make-engine.lua

-- This implementation is not (at all) aimed at optimization.
-- It allows the VM code (plume-data/engine/vm/*) to be made executable, while remaining readable and maintaining line consistency in error messages.
-- engine-opt is an automatically inlined and optimized version of this program.

-- Add all needed functions are loaded as globals
return function (plume)
	function plume._run_dev (runtime, chunk)
		require "plume-data/engine/vm/acc"
		require "plume-data/engine/vm/alu"
		require "plume-data/engine/vm/call"
		require "plume-data/engine/vm/core"
		require "plume-data/engine/vm/injection"
		require "plume-data/engine/vm/iter"
		require "plume-data/engine/vm/jump"
		require "plume-data/engine/vm/load"
		require "plume-data/engine/vm/meta"
		require "plume-data/engine/vm/others"
		require "plume-data/engine/vm/scope"
		require "plume-data/engine/vm/stack"
		require "plume-data/engine/vm/std"
		require "plume-data/engine/vm/store"
		require "plume-data/engine/vm/table"
		require "plume-data/engine/vm/utils"
	
		-- Creates stacks, handle arguments
		local vm =  --! to-remove
			_VM_INIT(plume, runtime, chunk)
		
		local op, arg1, arg2, vmerr, vmserr
		::DISPATCH::
			if vm.err then 
				return false, vm.err, vm.ip
			end

			op, arg1, arg2 = _VM_DECODE_CURRENT_INSTRUCTION(vm)

			if op < 32 then
				if op < 16 then
					if op < 8 then
						if op < 4 then
							if op < 2 then
								if op < 1 then
								else
LOAD_CONSTANT(vm, arg1, arg2)
								end
							else
								if op < 3 then
LOAD_TRUE(vm, arg1, arg2)
								else
LOAD_FALSE(vm, arg1, arg2)
								end
							end
						else
							if op < 6 then
								if op < 5 then
LOAD_EMPTY(vm, arg1, arg2)
								else
LOAD_LOCAL(vm, arg1, arg2)
								end
							else
								if op < 7 then
LOAD_STATIC(vm, arg1, arg2)
								else
STORE_LOCAL(vm, arg1, arg2)
								end
							end
						end
					else
						if op < 12 then
							if op < 10 then
								if op < 9 then
STORE_STATIC(vm, arg1, arg2)
								else
STORE_VOID(vm, arg1, arg2)
								end
							else
								if op < 11 then
TABLE_NEW(vm, arg1, arg2)
								else
TABLE_SET(vm, arg1, arg2)
								end
							end
						else
							if op < 14 then
								if op < 13 then
TABLE_INDEX(vm, arg1, arg2)
								else
TABLE_REGISTER_SELF(vm, arg1, arg2)
								end
							else
								if op < 15 then
TABLE_SET_META(vm, arg1, arg2)
								else
TABLE_SET_ACC(vm, arg1, arg2)
								end
							end
						end
					end
				else
					if op < 24 then
						if op < 20 then
							if op < 18 then
								if op < 17 then
TABLE_EXPAND(vm, arg1, arg2)
								else
CALL_INDEX_REGISTER_SELF(vm, arg1, arg2)
								end
							else
								if op < 19 then
TAG_META_KEY(vm, arg1, arg2)
								else
TAG_KEY(vm, arg1, arg2)
								end
							end
						else
							if op < 22 then
								if op < 21 then
ENTER_SCOPE(vm, arg1, arg2)
								else
LEAVE_SCOPE(vm, arg1, arg2)
								end
							else
								if op < 23 then
BEGIN_ACC(vm, arg1, arg2)
								else
CONCAT_TABLE(vm, arg1, arg2)
								end
							end
						end
					else
						if op < 28 then
							if op < 26 then
								if op < 25 then
CONCAT_TEXT(vm, arg1, arg2)
								else
CONCAT_CALL(vm, arg1, arg2)
								end
							else
								if op < 27 then
CHECK_IS_TEXT(vm, arg1, arg2)
								else
JUMP_IF(vm, arg1, arg2)
								end
							end
						else
							if op < 30 then
								if op < 29 then
JUMP_IF_NOT(vm, arg1, arg2)
								else
JUMP_IF_NOT_EMPTY(vm, arg1, arg2)
								end
							else
								if op < 31 then
JUMP_FOR(vm, arg1, arg2)
								else
JUMP(vm, arg1, arg2)
								end
							end
						end
					end
				end
			else
				if op < 48 then
					if op < 40 then
						if op < 36 then
							if op < 34 then
								if op < 33 then
JUMP_IF_PEEK(vm, arg1, arg2)
								else
JUMP_IF_NOT_PEEK(vm, arg1, arg2)
								end
							else
								if op < 35 then
GET_ITER(vm, arg1, arg2)
								else
FOR_ITER(vm, arg1, arg2)
								end
							end
						else
							if op < 38 then
								if op < 37 then
OP_ADD(vm, arg1, arg2)
								else
OP_MUL(vm, arg1, arg2)
								end
							else
								if op < 39 then
OP_SUB(vm, arg1, arg2)
								else
OP_DIV(vm, arg1, arg2)
								end
							end
						end
					else
						if op < 44 then
							if op < 42 then
								if op < 41 then
OP_NEG(vm, arg1, arg2)
								else
OP_MOD(vm, arg1, arg2)
								end
							else
								if op < 43 then
OP_POW(vm, arg1, arg2)
								else
OP_LT(vm, arg1, arg2)
								end
							end
						else
							if op < 46 then
								if op < 45 then
OP_EQ(vm, arg1, arg2)
								else
OP_AND(vm, arg1, arg2)
								end
							else
								if op < 47 then
OP_NOT(vm, arg1, arg2)
								else
OP_OR(vm, arg1, arg2)
								end
							end
						end
					end
				else
					if op < 56 then
						if op < 52 then
							if op < 50 then
								if op < 49 then
DUPLICATE(vm, arg1, arg2)
								else
SWITCH(vm, arg1, arg2)
								end
							else
								if op < 51 then
RETURN(vm, arg1, arg2)
								else
RETURN_FILE(vm, arg1, arg2)
								end
							end
						else
							if op < 54 then
								if op < 53 then
									goto END
								else
STD_LEN(vm, arg1, arg2)
								end
							else
								if op < 55 then
STD_TYPE(vm, arg1, arg2)
								else
STD_SEQ(vm, arg1, arg2)
								end
							end
						end
					else
						if op < 60 then
							if op < 58 then
								if op < 57 then
STD_ITEMS(vm, arg1, arg2)
								else
STD_ENUMERATE(vm, arg1, arg2)
								end
							else
								if op < 59 then
STD_IMPORT(vm, arg1, arg2)
								end
							end
						end
					end
				end
			end
goto DISPATCH		::END::
		return true, _STACK_GET(vm.mainStack)
	end
end