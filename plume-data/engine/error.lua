--File generated by preprocessor.lua
--[[This file is part of Plume
PlumeðŸª¶ is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.
PlumeðŸª¶ is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with PlumeðŸª¶.
If not, see <https://www.gnu.org/licenses/>.
]]

return function(plume)
	plume.error = {}

	function plume.error.getLineInfos(node)
		local filename = node.filename
		local code     = node.code
		local bpos     = node.bpos
		local epos     = node.epos
		local len      = 0
		local content  = code:sub(bpos, epos)
		
		plume.ast.browse(node, function(child)
			if child.bpos and child.bpos < bpos then
				bpos = child.bpos
			end
		end)

		local capturedLine, capturedBPos
		local capturedNoline = 0
		local currentPos = 0

		for line in (code.."\n"):gmatch('[^\n]*\n') do
			capturedNoline = capturedNoline + 1
			
			if currentPos + #line >= bpos then
				capturedLine = line
				currentPos = currentPos+1
				break
			end
			currentPos = currentPos + #line
		end

		if not capturedLine then
			return
		end
		
		if capturedLine:match('\n$') then
			capturedLine = capturedLine:gsub('\n$', '')
		end

		len  = math.min(epos - bpos + 1, #capturedLine - (bpos - currentPos))
		bpos = bpos - currentPos

		local indent = capturedLine:match('^%s*')
		capturedLine = capturedLine:sub(#indent+1, -1)
		
		bpos = bpos - #indent + 1

		return {
			line   = capturedLine,
			content = content,
			noline = capturedNoline,
			bpos   = bpos,
			len    = len,
			filename = node.filename
		}
	end

	function plume.error.formatLine(lineInfos, macro, syntax)
		local intro = string.format(
			"%sFile '%s', line %i",
			syntax and "" or "  ",
			lineInfos.filename,
			lineInfos.noline
		)
		

		if macro then
			intro = intro .. ", in macro " .. macro
		end

		local msg = intro

		msg = msg .. ": " ..lineInfos.line .. "\n"
		msg = msg .. (" "):rep(#intro + lineInfos.bpos+1) .. ("^"):rep(lineInfos.len)

		return msg
	end

	function plume.error.getNode(runtime, ip)
		local node
		for i=ip, 1, -1 do
			node = runtime.mapping[i]
			if node and node.bpos then
				break
			end
		end
		return node
	end

	function plume.error.makeMessage(message, node)
		if node and node.bpos then
			local lineInfos = plume.error.getLineInfos(node)
			message = message .. "\n"..plume.error.formatLine(lineInfos, nil, true)
		else
			message = "Unexpected error"
		end

		return message
	end

	function plume.error.makeCompilationError(node, message)
		return plume.error.makeMessage("Compilation error: " .. message, node)
	end

	function plume.error.makeSyntaxError(node, message)
		return plume.error.makeMessage("Syntax error: " .. message, node)
	end

	function plume.error.makeRuntimeError(runtime, ip, message)
		local node = plume.error.getNode(runtime, ip)
		local message = "Runtime error: " .. message

		local errorCallstack = {}
		local lineInfos = plume.error.getLineInfos(node)
		table.insert(
			errorCallstack,
			plume.error.formatLine(lineInfos, (not runtime.isFile) and runtime.name)
		)

		if plume.callstack then
			for i=#plume.callstack, 1, -1 do
				local chunk = plume.callstack[i]
				if chunk.macro.type == "macro" then
					local node = plume.error.getNode(chunk.macro, chunk.ip)
					if node then
						local lineInfos = plume.error.getLineInfos(node)
						table.insert(
							errorCallstack,
							plume.error.formatLine(lineInfos, (not chunk.macro.isFile) and chunk.macro.name)
						)
					end
				end
			end
		end

		message = message .. "\n\nTraceback (most recent call first):\n" .. table.concat(errorCallstack, "\n")

		return message
	end
end