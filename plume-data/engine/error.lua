--File generated by preprocessor.lua
--[[This file is part of Plume
PlumeðŸª¶ is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.
PlumeðŸª¶ is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with PlumeðŸª¶.
If not, see <https://www.gnu.org/licenses/>.
]]

return function(plume)
	plume.error = {}

	function plume.error.getLineInfos(node)
		local filename = node.filename
		local code     = node.code
		local bpos     = node.bpos
		local epos     = node.epos
		local len      = 0
		local content  = code:sub(bpos, epos)
		
		plume.ast.browse(node, function(child)
			if child.bpos and child.bpos < bpos then
				bpos = child.bpos
			end
		end)

		local capturedLine, capturedBPos
		local capturedNoline = 0
		local currentPos = 0

		for line in (code.."\n"):gmatch('[^\n]*\n') do
			capturedNoline = capturedNoline + 1
			
			if currentPos + #line >= bpos then
				capturedLine = line
				currentPos = currentPos+1
				break
			end
			currentPos = currentPos + #line
		end

		if not capturedLine then
			return
		end
		
		if capturedLine:match('\n$') then
			capturedLine = capturedLine:gsub('\n$', '')
		end

		len  = math.min(epos - bpos + 1, #capturedLine - (bpos - currentPos))
		bpos = bpos - currentPos

		local indent = capturedLine:match('^%s*')
		capturedLine = capturedLine:sub(#indent+1, -1)
		
		bpos = bpos - #indent + 1

		return {
			line   = capturedLine,
			content = content,
			noline = capturedNoline,
			bpos   = bpos,
			len    = len,
			filename = node.filename
		}
	end

	function plume.error.formatLine(lineInfos, macro, syntax)
		local intro = string.format(
			"%sFile '%s', line %i",
			syntax and "" or "  ",
			lineInfos.filename,
			lineInfos.noline
		)
		

		if macro then
			intro = intro .. ", in macro " .. macro
		end

		local msg = intro

		msg = msg .. ": " ..lineInfos.line .. "\n"
		msg = msg .. (" "):rep(#intro + lineInfos.bpos+1) .. ("^"):rep(lineInfos.len)

		return msg
	end

	function plume.error.getNode(runtime, ip)
		local node
		for i=ip, 1, -1 do
			node = runtime.mapping[i]
			if node and node.bpos then
				break
			end
		end
		return node
	end

	function plume.error.makeMessage(message, node)
		if node and node.bpos then
			local lineInfos = plume.error.getLineInfos(node)
			message = message .. "\n"..plume.error.formatLine(lineInfos, nil, true)
		else
			message = "Unexpected error"
		end

		return message
	end

	function plume.error.makeCompilationError(node, message)
		return plume.error.makeMessage("Compilation error: " .. message, node)
	end

	function plume.error.makeSyntaxError(node, message)
		return plume.error.makeMessage("Syntax error: " .. message, node)
	end

	local function simplifyErrorCallstack(errorCallstack)
		local windowSize = 1
		local detectedCount = 1
		while detectedCount > 0 and windowSize < #errorCallstack/2 do
			detectedCount = 0
			for i=1, #errorCallstack-windowSize do
				for j=i+windowSize, #errorCallstack, windowSize do
					local detection = true
					for k=0, windowSize do
						if errorCallstack[i+k] ~= errorCallstack[j+k] then
							detection = false
							break
						end
					end
					if not detection then
						break
					end
					detectedCount = detectedCount + i/windowSize
				end

				if detectedCount > 3 then
					local newErrorCallstack = {}
					for j=1, i-1 do
						table.insert(newErrorCallstack, errorCallstack[j])
					end
					if windowSize>1 then
						table.insert(newErrorCallstack, "  These lines are repeated " .. (detectedCount) .. " times:")
						table.insert(newErrorCallstack, "  -------------")
					end

					
					for j=i, i+windowSize-1 do
						table.insert(newErrorCallstack, errorCallstack[j])
					end


					if windowSize>1 then
						table.insert(newErrorCallstack, "  -------------")
					else
						table.insert(newErrorCallstack, "    ...")
						table.insert(newErrorCallstack, "   (same line " .. detectedCount .. " more times)")
						table.insert(newErrorCallstack, "    ...")
					end

					for j=i+(detectedCount+1)*windowSize+1, #errorCallstack do
						table.insert(newErrorCallstack, errorCallstack[j])
					end
					errorCallstack = newErrorCallstack
					break
				end
			end

			if detectedCount == 0 then
				windowSize = windowSize + 1
				detectedCount = 1
			end
		end
		return errorCallstack
	end

	local function findNodeParentMacro (node)
		if node.name == "MACRO" then
			return node.debugMacroName
		elseif node.parent then
			return findNodeParentMacro(node.parent)
		end
	end

	function plume.error.makeRuntimeError(runtime, ip, message)
		local node = plume.error.getNode(runtime, ip)
		local message = "Runtime error: " .. message

		local errorCallstack = {}
		local lineInfos = plume.error.getLineInfos(node)
		table.insert(
			errorCallstack,
			plume.error.formatLine(lineInfos, findNodeParentMacro (node))
		)

		if runtime.callstack then
			for i=#runtime.callstack, 1, -1 do
				local source = runtime.callstack[i]
				local node
				if source.macro.type == "macro" then
					node = plume.error.getNode(runtime, source.ip)
				elseif source.macro.type == "luaFunction" and i>1 then
					node = plume.error.getNode(runtime, source.ip)
				end
				if node then
					local parentMacro = runtime.callstack[i-1]
					local parentMacroName = parentMacro and parentMacro.macro.type == "macro" and parentMacro.macro.name
					local parentMacroName = parentMacroName or findNodeParentMacro (node)

					local lineInfos = plume.error.getLineInfos(node)
					local formatedLine = plume.error.formatLine(lineInfos, parentMacroName)
					table.insert(errorCallstack, formatedLine)
				end
			end
		end

		if #errorCallstack > 10 then
			errorCallstack = simplifyErrorCallstack(errorCallstack)
		end

		local traceback = table.concat(errorCallstack, "\n")
		message = message .. "\n\nTraceback (most recent call first):\n" .. traceback

		return message
	end
end