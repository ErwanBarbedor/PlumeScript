--[[This file is part of Plume

PlumeðŸª¶ is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

PlumeðŸª¶ is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with PlumeðŸª¶.
If not, see <https://www.gnu.org/licenses/>.
]]

-- Create the core big-dispatch-loop
-- Called by make-engine-opt.lua

local plume = {}
require"plume-data/engine/utils"(plume)
local lfs = require "lfs"

local header = [=[--[[This file is part of Plume

PlumeðŸª¶ is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

PlumeðŸª¶ is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with PlumeðŸª¶.
If not, see <https://www.gnu.org/licenses/>.
]]

-- Generated by build-tools/make-engine.lua

-- This implementation is not (at all) aimed at optimization.
-- It allows the VM code (plume-data/engine/vm/*) to be made executable, while remaining readable and maintaining line consistency in error messages.
-- engine-opt is an automatically inlined and optimized version of this program.

-- Add all needed functions are loaded as globals
return function (plume)
]=]

local import = {}
for file in lfs.dir("plume-data/engine/vm") do
	if file:match('%.lua$') then
		file = file:gsub('%.lua$', '')
		table.insert(import, string.format("\trequire \"plume-data/engine/vm/%s\"\n", file))
	end
end
import = table.concat(import)

local init = [[
	function plume._run_dev (chunk, arguments)
		-- Creates stacks, handle arguments
		local vm = _VM_INIT(plume, chunk, arguments)
		
		local op, arg1, arg2
		::DISPATCH::
			-- !begin-to-remove
			if vm.err then 
				return false, vm.err, vm.ip, vm.chunk
			end
			if vm.serr then
				return false, unpack(vm.serr)
			end
			-- !end-to-remove

			-- Handle jump and incremente IP
			_VM_TICK(vm)

			op, arg1, arg2 = _VM_DECODE_CURRENT_INSTRUCTION(vm)

]]

local dispatch, labels = {}, {}
local count = 1
for op_name in plume.ops_names:gmatch("%S+") do

	table.insert(dispatch, "\t\t\t")

	if count > 1 then
		table.insert(dispatch, "else")
	end

	table.insert(dispatch, string.format("if op == %i then goto %s\n", count, op_name))

	if op_name ~= "END" then
		table.insert(labels,string.format( "\t\t\t::%s::\n\t\t\t\t%s(vm, arg1, arg2)\n\t\t\t\tgoto DISPATCH\n", op_name, op_name))
	end
	count = count + 1
end
table.insert(dispatch, "\t\t\tend\n\n")
dispatch = table.concat(dispatch)
labels = table.concat(labels)

local footer = "\t\t::END::\n\t\treturn true, _STACK_GET(vm.mainStack)\n\tend\nend"


local result = {header, import, init, dispatch, labels, footer}


local f = io.open("plume-data/engine/engine.lua", "w")
	f:write(table.concat( result, ""))
f:close()