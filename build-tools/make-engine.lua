--[[This file is part of Plume

PlumeðŸª¶ is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

PlumeðŸª¶ is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with PlumeðŸª¶.
If not, see <https://www.gnu.org/licenses/>.
]]

-- Create the core big-dispatch-loop
-- Called by makevm.lua

local plume = {}
require"plume-data/engine/utils"(plume)

local header = [=[--[[This file is part of Plume

PlumeðŸª¶ is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

PlumeðŸª¶ is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with PlumeðŸª¶.
If not, see <https://www.gnu.org/licenses/>.
]]

-- Generated by build-tools/make-engine.lua

-- This implementation is not (at all) aimed at optimization.
-- It allows the VM code (plume-data/engine/vm/*) to be made executable, while remaining readable and maintaining line consistency in error messages.
-- engine-opt is an automatically inlined and optimized version of this program.

-- Add all needed functions are loaded as globals
require "plume-data/vm/_load_all"

return function (plume)
	function plume.run (chunk, arguments)
		-- Creates stacks, handle arguments
		local vm = _VM_INIT(chunk, arguments)
		
		local op, arg1, arg2
		::DISPATCH::
			if plume.hook then
				_VM_DEBUG(vm, plume.hook)
			end

			-- Handle jump and incremente IP
			_VM_TICK(vm)

			op, arg1, arg2 = _VM_DECODE_CURRENT_INSTRUCTION(vm)

]=]

local dispatch, labels = {}, {}
local count = 1
for op_name in plume.ops_names:gmatch("%S+") do

	table.insert(dispatch, "\t\t\t")

	if count > 1 then
		table.insert(dispatch, "else")
	end

	table.insert(dispatch, string.format("if op == %i then goto %s\n", count, op_name))

	if op_name ~= "END" then
		table.insert(labels,string.format( "\t\t\t::%s::\n\t\t\t\t%s(vm, arg1, arg2)\n", op_name, op_name))
	end
	count = count + 1
end
table.insert(dispatch, "\t\t\tend\n\n")
dispatch = table.concat(dispatch)
labels = table.concat(labels)

local footer = "\t\tgoto DISPATCH\n\t\t::END::\n\tend\nend"


local result = {header, dispatch, labels, footer}


io.open("plume-data/engine/engine.lua", "w"):write(table.concat( result, ""))