--[[This file is part of Plume

PlumeðŸª¶ is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

PlumeðŸª¶ is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with PlumeðŸª¶.
If not, see <https://www.gnu.org/licenses/>.
]]

-- Create the core big-dispatch-loop
-- Called by make-engine-opt.lua

require"build-tools/make-vmdoc"

plume = require"plume-data/engine/init"
local lfs = require "lfs"

local header = [=[--[[This file is part of Plume

PlumeðŸª¶ is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

PlumeðŸª¶ is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with PlumeðŸª¶.
If not, see <https://www.gnu.org/licenses/>.
]]

-- Generated by build-tools/make-engine.lua

-- This implementation is not (at all) aimed at optimization.
-- It allows the VM code (plume-data/engine/vm/*) to be made executable, while remaining readable and maintaining line consistency in error messages.
-- engine-opt is an automatically inlined and optimized version of this program.

-- Add all needed functions are loaded as globals
return function (plume)
	function plume._run_dev (runtime, chunk)
]=]

local import = {}
for file in lfs.dir("plume-data/engine/vm") do
	if file:match('%.lua$') then
		file = file:gsub('%.lua$', '')
		table.insert(import, string.format("\t\trequire \"plume-data/engine/vm/%s\"\n", file))
	end
end
import = table.concat(import)

local init = [[
	
		-- Creates stacks, handle arguments
		local vm =  --! to-remove
			_VM_INIT(plume, runtime, chunk)
		
		local op, arg1, arg2, vmerr, vmserr
		::DISPATCH::
			if vm.err then 
				return false, vm.err, vm.ip
			end

			op, arg1, arg2 = _VM_DECODE_CURRENT_INSTRUCTION(vm)

]]

local uselabelGoto = false

local dispatch, labels = {}, {}
local totalCount = 0
local op_namesTable = {}
for op_name in plume.ops_names:gmatch("%S+") do
	table.insert(op_namesTable, op_name)

	if op_name ~= "END" then
		table.insert(labels,string.format( "\t\t\t::%s::\n\t\t\t\t%s(vm, arg1, arg2)\n\t\t\t\tgoto DISPATCH\n", op_name, op_name))
	end
end

local function handleChoice(limDown, limUp, indent)
	indent = indent or "\t\t\t"
	local middlePoint = math.floor((limDown + limUp) / 2)
	
	table.insert(dispatch, string.format(indent.."if op < %i then\n", middlePoint))
	if middlePoint > 1 then
		if limUp - limDown > 2 then
			handleChoice(limDown, middlePoint, indent.."\t")
		else
			if  uselabelGoto or op_namesTable[middlePoint-1] == "END" then
				table.insert(dispatch, string.format(indent.."\tgoto %s\n", op_namesTable[middlePoint-1]))
			else
				table.insert(dispatch,string.format("%s(vm, arg1, arg2)\n", op_namesTable[middlePoint-1]))
			end
		end
	end
	
	if middlePoint <= #op_namesTable then
		table.insert(dispatch, indent.."else\n")
		if limUp - limDown > 2 then
			handleChoice(middlePoint+1, limUp, indent.."\t")
		else
			if uselabelGoto or op_namesTable[middlePoint] == "END" then
				table.insert(dispatch, string.format(indent.."\tgoto %s\n", op_namesTable[middlePoint]))
			else
				table.insert(dispatch,string.format("%s(vm, arg1, arg2)\n", op_namesTable[middlePoint]))
			end
		end
	end
	table.insert(dispatch, indent.."end\n")
end

local function makeDispatchBinary()
	-- Set to the nearest  2^n
	local totalCount = 2^(math.floor(0.5+math.log(#op_namesTable, 2)))
	handleChoice(0, totalCount)
end

local function makeDispatchFlat()
	for i, op_name in ipairs(op_namesTable) do
		table.insert(dispatch, "\t\t\t")
		if i>1 then
			table.insert(dispatch, "else")
		end
		table.insert(dispatch, string.format("if op == %i then", i))
		if uselabelGoto or op_name == "END" then
			table.insert(dispatch, string.format("\n\t\t\t\tgoto %s\n",op_name))
		else
			table.insert(dispatch,string.format("\n\t\t\t\t%s(vm, arg1, arg2)\n", op_name))
		end
	end
	table.insert(dispatch, "end\n")
end

makeDispatchBinary()
-- makeDispatchFlat()

dispatch = table.concat(dispatch)

if uselabelGoto then
	labels = table.concat(labels)
else
	labels = "goto DISPATCH"
end

local footer = "\t\t::END::\n\t\treturn true, _STACK_GET(vm.mainStack)\n\tend\nend"


local result = {header, import, init, dispatch, labels, footer}


local f = io.open("plume-data/engine/engine.lua", "w")
	f:write(table.concat( result, ""))
f:close()